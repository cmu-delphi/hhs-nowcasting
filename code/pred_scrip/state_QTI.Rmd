---
title: "state_QTI"
output: html_document
date: "2024-05-06"
---

# Purpose

Run quantile tracking on top of current nowcasts

# Read data
```{r}
library(lubridate)
library(tidyverse)
library(vroom)

state_pred = vroom("../../predictions/bl_versioned_hhs_mixed.csv")
```

```{r}
state_lr = readRDS("assets_QTI/state_lr_frame.RDS")
state_score_frame = readRDS("assets_QTI/state_score_frame.RDS")

miscover_lvl = 0.2; lower_q = miscover_lvl; upper_q = 1 - miscover_lvl
state_QT = c()


dump_dates = c(as.Date("2021-04-01"), as.Date("2021-05-01"), as.Date("2021-06-01"), 
               as.Date("2021-07-01"), as.Date("2021-08-01"), as.Date("2021-09-01"),
               as.Date("2021-10-01"), as.Date("2021-11-01"), as.Date("2021-12-01")) - 1



for (window_date in dump_dates) {

  max_date = as.numeric(as.Date("2022-01-31") - window_date) - 1

  for (i in seq(1, min(50, max_date))) {
      
      window_date = as.Date(window_date, "1970-01-01")
      version = window_date + i
      version = as.Date(version, "1970-01-01")


      tmp = state_pred %>%
        # Stay between current dump and next dump
        filter(issue_date == version) %>%
        filter(time_value > window_date & 
                 time_value < ceiling_date(window_date + 1, "month"))
      if (nrow(tmp) == 0) {
        next
      }
      
      
      interval_tmp = tmp %>%
        select(geo_value, time_value, issue_date, state_fit, GT, 
               resid) %>%
        inner_join(state_score_frame, by = "geo_value") %>%
        # Padding parameter, TODO: Change to additive padding (how?)
        mutate(d_t = pmax(state_fit, 1)) %>%
        # Construct asymmetric intervals
        # Upper score is used to construct the LOWER end point
        mutate(
          lower = pmax(state_fit - lower_score * state_fit, 0),
          upper = pmax(state_fit + upper_score * state_fit, 0)
        )

      state_QT = rbind(state_QT, interval_tmp)

  }
  
  # Between world, compute coverage and update scores 
  miscover_freq = state_QT %>%
    filter(time_value >= as.Date(window_date)) %>%
    filter(time_value == issue_date) %>%
    group_by(geo_value) %>%
    # Track lower and upper seperately 
    summarise(update_lower = sum((GT < lower) - miscover_lvl),
              update_upper = sum((GT > upper) - miscover_lvl))

  state_lr = state_QT %>%
    group_by(geo_value) %>%
    filter(time_value >= as.Date(window_date)) %>%
    filter(time_value == issue_date) %>%
    mutate(upper_scores = (state_fit - GT) / d_t) %>%
    mutate(lower_scores = -(state_fit - GT) / d_t) %>%
    summarise(upper_lr = 0.03 * max(upper_scores),
              lower_lr = 0.03 * max(lower_score)) 
    
  state_score_frame = state_score_frame %>%
    inner_join(state_lr, by = "geo_value") %>%
    inner_join(miscover_freq, by = "geo_value") %>%
    group_by(geo_value) %>%
    # Why is lower minus???
    summarise(lower_tmp = lower_score + upper_lr * update_lower,
              upper_tmp = upper_score + lower_lr * update_upper) %>%
    mutate(lower_score = pmin(lower_tmp, upper_tmp),
           upper_score = pmax(lower_tmp, upper_tmp)) %>%
    select(-lower_tmp, -upper_tmp)
  

}

write.csv(state_QT, "../../predictions/scenario1_state_quantileTracker.csv", row.names = FALSE)

```




```{r}
cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
              "#0072B2", "#D55E00", "#CC79A7")
fills = c("Actual Hospitalizations" = cbPalette[1], "Nowcasts" = cbPalette[6])
cols = c("Nowcasts" = cbPalette[6])
states = unique(state_QT$geo_value)

# pdf("figs/state_intervals.pdf", width=10, height=8)

for (s in states) {
  data_state = state_QT %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date) %>%
    filter(time_value <= as.Date("2021-12-01"))
  
  p1 = ggplot(data_state, aes(x = time_value, y = GT)) +
    geom_bar(stat = "identity", aes(fill = "Actual Hospitalizations"), alpha = 0.7) +
    geom_line(aes(x = time_value, y = state_fit, color = "Nowcasts")) +
    geom_ribbon(aes(x = time_value, ymin = lower, ymax = upper, fill = "Nowcasts"), alpha = 0.4) +
    scale_color_manual(name = "", values = fills) +
    scale_fill_manual(name = "", values = fills) +
    scale_x_date(date_breaks = "1 month", expand = c(0.01, 0.05),
                 labels = scales::label_date_short()) +
    xlab("Date") +
    ylab("Hospitalization rate") +
    theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle(paste0(toupper(s), ", nowcasts and interval"))
    
  print(p1)
  
}

# dev.off()
```


# Plot coverage of upper interval and upper score
```{r}
cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
              "#0072B2", "#D55E00", "#CC79A7")
colrs = c("scores" = cbPalette[6], "lr" = cbPalette[4], "coverage" = cbPalette[2])

# 
trans = function(x, from_range, to_range) {
  (x - from_range[1]) / (from_range[2] - from_range[1]) *
    (to_range[2] - to_range[1]) + to_range[1]
}
          
states = unique(state_QT$geo_value)

# pdf("figs/coverage_scores.pdf", width = 10, height = 8)

for (s in states) {
  
  data_state = state_QT %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date)
  
  data_coverage = state_QT %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date) %>%
    mutate(month = floor_date(time_value, "month")) %>%
    group_by(geo_value, month) %>%
    summarise(coverage = mean(GT < upper)) %>%
    rename(time_value = month) %>%
    complete(time_value = seq.Date(as.Date("2021-04-01"), as.Date("2021-11-30"),
            by = "day")) %>%
    fill(coverage, .direction = "down")  
  

  upper_scores_range = data_state %>%
    select(upper_score) %>%
    range
  
  coverage_range = c(0, 1)
  
  trans_coverage_score = function(x) trans(x, coverage_range, upper_scores_range)
  trans_score_coverage = function(x) trans(x, upper_scores_range, coverage_range)
  
  p1 = ggplot(data_state) +
    geom_line(aes(x = time_value, y = upper_score, color = "scores")) +
    geom_line(data = data_coverage, aes(x = time_value, 
      y = trans_coverage_score(coverage), color = "coverage")) +
    scale_color_manual(name = "", values = colrs) +
    scale_x_date(date_breaks = "1 month", expand = c(0.01, 0.05),
                 labels = scales::label_date_short()) +
    scale_y_continuous(name = "Scores", 
      breaks = signif(seq(min(data_state$upper_score), max(data_state$upper_score), length.out = 5), 3),
      sec.axis = sec_axis(trans = trans_score_coverage,
                          breaks = scales::pretty_breaks(n = 5),
                          name = "Monthly averaged coverage of nowcasts")) +
    ylab("Scores") +
    xlab("Time value") +
    theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle(toupper(s))
    
  print(p1)
  
}

# dev.off()
```
