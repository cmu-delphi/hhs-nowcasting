---
title: "coverage"
output: html_document
date: "2024-04-04"
---

# Purpose

We analyze the coverage properties of quantile tracking algorithm on state-lvl stuff.

```{r, message=FALSE}
library(tidyverse)
library(vroom)

uspop = covidcast::state_census %>%
  select(ABBR, POPESTIMATE2019) %>%
  rename(geo_value = ABBR) %>%
  rename(pop = POPESTIMATE2019) %>%
  mutate(geo_value = tolower(geo_value)) %>%
  slice(., 2:(n() - 4))


labels_hosp = vroom("../versioned_feature/ground_truth.csv") %>%
  filter(time_value >= as.Date("2020-11-01") & time_value <= as.Date("2022-07-31")) %>%
  select(-issue_date) %>%
  mutate(time_value = as.Date(time_value)) %>%
  filter(geo_value != "vi") %>%
  inner_join(uspop, by = "geo_value") %>%
  mutate(GT = GT / pop * 10^5)


```


```{r}
state_quant = vroom("../predictions/scenario1_state_quantileTracker.csv") %>%
  filter(time_value < as.Date("2021-12-01"))
```


```{r}
nowcasts_list = state_quant %>%
  filter(time_value == issue_date) %>%
  group_by(geo_value) %>%
  group_split(.keep = FALSE)
names(nowcasts_list) = unique(state_quant$geo_value)
```



```{r}
ak = nowcasts_list[["ak"]]
al = nowcasts_list[["al"]]
il = nowcasts_list[["il"]]
ma = nowcasts_list[["ma"]]
```



```{r}
funny_bus = state_quant %>%
  group_by(geo_value) %>%
  filter(time_value == issue_date) %>%
  filter(lower > state_fit |
           upper < state_fit)
```


```{r}
coverage = state_quant %>%
  filter(issue_date == time_value) %>%
  group_by(geo_value) %>%
  summarise(
    upper_cov = mean(GT < upper),
    lower_cov = mean(lower < GT)
  )

```


# Intervals

```{r}
cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
              "#0072B2", "#D55E00", "#CC79A7")
fills = c("Actual Hospitalizations" = cbPalette[1], "Nowcasts" = cbPalette[6])
cols = c("Nowcasts" = cbPalette[6])
states = unique(coverage$geo_value)

pdf("figs/QT-state_intervals.pdf", width=10, height=8)

for (s in states) {
  data_state = state_quant %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date) %>%
    filter(time_value <= as.Date("2021-12-01"))
  
  p1 = ggplot(data_state, aes(x = time_value, y = GT)) +
    geom_bar(stat = "identity", aes(fill = "Actual Hospitalizations"), alpha = 0.7) +
    geom_line(aes(x = time_value, y = state_fit, color = "Nowcasts")) +
    geom_ribbon(aes(x = time_value, ymin = lower, ymax = upper, fill = "Nowcasts"), alpha = 0.4) +
    scale_color_manual(name = "", values = fills) +
    scale_fill_manual(name = "", values = fills) +
    scale_x_date(date_breaks = "1 month", expand = c(0.01, 0.05),
                 labels = scales::label_date_short()) +
    xlab("Date") +
    ylab("Hospitalization rate") +
    theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle(paste0(toupper(s), ", nowcasts and interval"))
    
  print(p1)
  
}

dev.off()
```




# Upper interval coverage and score 
```{r, message=FALSE}
cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
              "#0072B2", "#D55E00", "#CC79A7")
colrs = c("scores" = cbPalette[6], "lr" = cbPalette[4], "coverage" = cbPalette[2])

# 
trans = function(x, from_range, to_range) {
  (x - from_range[1]) / (from_range[2] - from_range[1]) *
    (to_range[2] - to_range[1]) + to_range[1]
}
          
states = unique(state_quant$geo_value)

# pdf("figs/coverage_scores.pdf", width = 10, height = 8)

for (s in states) {
  
  data_state = state_quant %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date)
  
  data_coverage = state_quant %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date) %>%
    mutate(month = floor_date(time_value, "month")) %>%
    group_by(geo_value, month) %>%
    summarise(coverage = mean(GT < upper)) %>%
    rename(time_value = month) %>%
    complete(time_value = seq.Date(as.Date("2021-04-01"), as.Date("2021-11-30"),
            by = "day")) %>%
    fill(coverage, .direction = "down")  
  

  upper_scores_range = data_state %>%
    select(upper_score) %>%
    range
  
  coverage_range = c(0, 1)
  
  trans_coverage_score = function(x) trans(x, coverage_range, upper_scores_range)
  trans_score_coverage = function(x) trans(x, upper_scores_range, coverage_range)
  
  p1 = ggplot(data_state) +
    geom_line(aes(x = time_value, y = upper_score, color = "scores")) +
    geom_line(data = data_coverage, aes(x = time_value, 
      y = trans_coverage_score(coverage), color = "coverage")) +
    scale_color_manual(name = "", values = colrs) +
    scale_x_date(date_breaks = "1 month", expand = c(0.01, 0.05),
                 labels = scales::label_date_short()) +
    scale_y_continuous(name = "Scores", 
      breaks = signif(seq(min(data_state$upper_score), max(data_state$upper_score), length.out = 5), 3),
      sec.axis = sec_axis(trans = trans_score_coverage,
                          breaks = scales::pretty_breaks(n = 5),
                          name = "Monthly coverage")) +
    ylab("Scores") +
    xlab("Time value") +
    theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle(paste0(toupper(s), " , monthly coverage of upper interval"))
    
  print(p1)
  
}

# dev.off()
```


# Lower interval coverage and scores 
```{r, message=FALSE}
cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
              "#0072B2", "#D55E00", "#CC79A7")
colrs = c("scores" = cbPalette[6], "lr" = cbPalette[4], "coverage" = cbPalette[2])

# 
trans = function(x, from_range, to_range) {
  (x - from_range[1]) / (from_range[2] - from_range[1]) *
    (to_range[2] - to_range[1]) + to_range[1]
}
          
states = unique(state_quant$geo_value)

# pdf("figs/coverage_scores.pdf", width = 10, height = 8)

for (s in states) {
  
  data_state = state_quant %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date)
  
  data_coverage = state_quant %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date) %>%
    mutate(month = floor_date(time_value, "month")) %>%
    group_by(geo_value, month) %>%
    summarise(coverage = mean(lower < GT)) %>%
    rename(time_value = month) %>%
    complete(time_value = seq.Date(as.Date("2021-04-01"), as.Date("2021-11-30"),
            by = "day")) %>%
    fill(coverage, .direction = "down")  
  

  lower_scores_range = data_state %>%
    select(lower_score) %>%
    range
  
  coverage_range = c(0, 1)
  
  trans_coverage_score = function(x) trans(x, coverage_range, lower_scores_range)
  trans_score_coverage = function(x) trans(x, lower_scores_range, coverage_range)
  
  p1 = ggplot(data_state) +
    geom_line(aes(x = time_value, y = lower_score, color = "scores"),
              linetype = "dashed", alpha = 0.7, linewidth = 0.9) +
    geom_line(data = data_coverage, aes(x = time_value, 
      y = trans_coverage_score(coverage), color = "coverage"),
      alpha = 0.7, linewidth = 0.9) +
    scale_color_manual(name = "", values = colrs) +
    scale_x_date(date_breaks = "1 month", expand = c(0.01, 0.05),
                 labels = scales::label_date_short()) +
    scale_y_continuous(name = "Scores", 
      breaks = signif(seq(min(data_state$lower_score), max(data_state$lower_score), length.out = 5), 3),
      sec.axis = sec_axis(trans = trans_score_coverage,
                          breaks = scales::pretty_breaks(n = 5),
                          name = "Monthly coverage")) +
    ylab("Scores") +
    xlab("Time value") +
    theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle(paste0(toupper(s), " , monthly coverage of lower interval"))
    
  print(p1)
  
}

# dev.off()
```



# Compute and plot month-wise coverage

```{r}
cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
              "#0072B2", "#D55E00", "#CC79A7")
colrs = c("Upper coverage" = cbPalette[7], "Lower coverage" = cbPalette[6])
          
states = unique(coverage$geo_value)
for (s in states) {
  
  data_state = state_quant %>%
    filter(geo_value == s) %>%
    filter(time_value == issue_date) %>%
    mutate(month = floor_date(time_value, "month")) %>%
    group_by(month) %>%
    summarise(
      upper_coverage = mean(GT < upper),
      lower_coverage = mean(GT > lower)) %>%
    rename(time_value = month) %>%
    complete(time_value = seq.Date(as.Date("2021-04-01"), as.Date("2021-11-30"),
            by = "day")) %>%
    fill(upper_coverage, lower_coverage, .direction = "down")
  
  p1 = ggplot(data_state) +
    geom_step(aes(x = time_value, y = upper_coverage, color = "Upper coverage"), 
              linetype = "dashed", alpha = 0.7, linewidth = 0.9) +
    geom_step(aes(x = time_value, y = lower_coverage, color = "Lower coverage"), 
              alpha = 0.7, linewidth = 0.9) +
    scale_color_manual(name = "", values = colrs) +
    scale_x_date(date_breaks = "1 month", expand = c(0.01, 0.05),
                 labels = scales::label_date_short()) +
    scale_y_continuous(n.breaks = 5) +
    ylab("Coverage") +
    xlab("Time value") +
    theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle(toupper(s))
    
  print(p1)
  
}
```


# Correlation between coverage and percentage residual

```{r}
residual_coverage = state_quant %>%
  filter(time_value == issue_date) %>%
  mutate(month = floor_date(time_value, "month")) %>%
  group_by(geo_value, month) %>%
  summarise(coverage = mean(lower < GT & GT < upper),
            res_per = mean( resid / state_fit)) %>%
  rename(time_value = month) 
  

corr_coverage_res = residual_coverage %>%
  ungroup() %>%
  group_by(geo_value) %>%
  summarise(corr = cor(coverage, res_per))

```





